# Accepts n (int) from standard input and writes n! (computed recursively) to standard output.

    readi     r3            # read n
    pushrw    r3 sp         # mem[sp++] = n
    calln     ra factorial  # n! = factorial(n)
    addi      sp -4         # sp = sp - 4
    writei    rv            # write n!
    halt                    # halt the machine

# int factorial(int n):
#   input : r3 = n
#   output: rv = n!
#   temps: r4, r5

# Save ra and fp, and set fp to sp.
factorial:
    pushrw    ra sp           # mem[sp--] = ra
    pushrw    fp sp           # mem[sp--] = fp
    copy      fp sp           # fp = sp

    # Save registers used.
    pushrw    r3 sp           # mem[sp--] = r3
    pushrw    r4 sp           # mem[sp--] = r4
    pushrw    r5 sp           # mem[sp--] = r5

    loadnw    r3 fp 12        # n = mem[fp + 3]
    jnezn     r3 factorialRec # if n != 0 jump to 16 (recursive step),
                              # else fall through (base case)

    # Base case.
    seti      rv 1            # output = 1
    jumpn     restore         # jump to restore

# Recursive step.
factorialRec:
    copy      r5 r3           # r5 = n
    addi      r5 -1           # n = n - 1
    pushrw    r5 sp           # mem[sp--] = n - 1
    calln     ra factorial    # (n-1)! = factorialRec(n-1)
    addi      sp 4            # sp = sp + 4
    mul       rv r3 rv        # n! = n(n-1)!

restore:
    # Restore registers used.
    poprw     r5 sp           # r5 = mem[++sp]
    poprw     r4 sp           # r4 = mem[++sp]
    poprw     r3 sp           # r3 = mem[++sp]

    # Restore fp and ra, and jump to ra (caller).
    poprw     fp sp           # fp = mem[++sp]
    poprw     ra sp           # ra = mem[++sp]
    jumpr     ra              # jump to caller
